## Shorthand
The pipeline for the rank distance can be easily run as follows:
```bash
make rank_tree
make rankindl_tree
```
The DCJ pipeline, on the other hand, relies on Python 2 in an intermidiate step.
In addition, one must have a working installation of Gurobi 9.5.1.
The steps must be the following:
```bash
conda activate dcj     # activate env with python 2
make dcj_matrix_5000.csv
conda deactivate
../70-tree/rooted-nj-tree-with-outgroup.R dcj_matrix.csv dcj_tree L20
```

## Detailed steps
The following steps are run by the Makefile.
### 1) Generate dummy data
1.1) Generate dummy tree:
```bash
ngesh -L 20 -x enum -r seed > dummy_tree.nwk
```
1.2) Generate synthetic genomes:
```bash
./simulate_dcj.py -g 5000 -x 2 -i 0.2 -e 0.4 --indel_size_zipf 4 -c -l dummy_tree.nwk 2> simulate_dcj.log > dummy_data.unimog
```
The parameters are the following:
- `-g`: number of genes in root genome;
- `-x`: number of chromosomes in root genome;
- `-i`: insertion rate;
- `-e`: deletion rate;
- `-c`: circular genomes only;
- `-l`: output the leaves only;
- `--indel_size_zipf`: size of indel segment sampled from Zipf distribution.
### 2) Compute rank and rank-indel
2.1) Convert `unimog` file to `adj` files: (This step is required for Step 5.)
```bash
# Split the genomes in Unimog file into separate files
./split_unimog dummy_data.unimog
# Convert each genome into a format suitable to the script that computes rank distance
for i in L*.txt; do
    ./unimog2adj.py ${i} > ${i}.adj
done
```
2.2) Run rank:
```bash
ls L*.adj | xargs ../60-matrix/gen_pairwise_comparisons.py | parallel --colsep '\t' ../60-matrix/rank-joao/dist.py 0 0 {} | tr '\t' ',' | ../60-matrix/build_distance_matrix.py - > rank_matrix.csv
```
2.3) Run rank-indel:
```bash
ls L*.adj | xargs ../60-matrix/gen_pairwise_comparisons.py | parallel --colsep '\t' ../60-matrix/rank-joao/dist.py 0 1 {} | tr '\t' ',' | ../60-matrix/build_distance_matrix.py - > rankindl_matrix.csv
```
### 2) Compute DCJ-Indel
2.1) Split `unimog` file into smaller ones with **all** pairwise combinations of genomes:
```bash
./unimog2pairs.py dummy_data.unimog
```
2.2) Run DCJ-Indel 
```bash
ls *_vs_*.unimog | parallel --colsep '\t' ./dcjindel.sh {} | tr '\t' ',' | ../60-matrix/build_distance_matrix.py - > dcj_matrix.csv
```
### 3) Plot trees
3.1) Plot trees using distance matrices generated by (4), (5), and (6).
For the tree generated in Step 1 by the seed provided, the outgroup is **L20**.
```bash
../70-tree/rooted-nj-tree-with-outgroup.R rank_matrix.csv rank_tree L20
../70-tree/rooted-nj-tree-with-outgroup.R rankindl_matrix.csv rankindl_tree L20
../70-tree/rooted-nj-tree-with-outgroup.R dcj_matrix.csv dcj_tree L20
```
3.2) Finally, load the Newick files in `analysis.ipynb` and make comparisons and plots!

## Measuring performance
The performance measure should be done when the distance is computed.
After having generated the Gen files, run the following:
```bash
ls *.gen | xargs ../60-matrix/gen_pairwise_comparisons.py > comparisons.txt
time cat comparisons.txt | parallel --colsep '\t' ${DIST} {}
```
where `DIST` is the script that computes a rearrangement distance.
