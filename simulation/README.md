## Experimental design
We have the following parameters:
- Number of genes (`g`);
- Number of chromosomes (`x`);
- Number of taxa (`L`);
- Insertion rate (`i`);
- Deletion rate (`e`).

We fix `L=20`, `i=0.2`, and `e=0.4`.
The number of chromosomes is an interesing parameter to tweak, but we will keep `x=2` to emulate the typical number of chromosomes in prokaryotic cells.
Although most are haploid (they have one chromosome without a corresponding pair), the presence of plasmids is very common and some bacteria, such as *Vibrio chrolerae*, have two chromosomes.
To evaluate the scalability of the methods, we shall vary the number of genes.
We will run three experiments with 5000, 10000, and 20000 genes.

## Steps to run simulation
1) Generate dummy tree:
```bash
ngesh -L 20 -x enum -r seed > dummy_tree.nwk
```
2) Generate synthetic genomes:
```bash
./simulate_dcj.py -g 4000 -x 2 -i 0.2 -e 0.4 --indel_size_zipf 4 -c -l dummy_tree.nwk 2> simulate_dcj.log > dummy_data.unimog
```
- `-g`: number of genes in root genome;
- `-x`: number of chromosomes in root genome;
- `-i`: insertion rate;
- `-e`: deletion rate;
- `-c`: circular genomes only;
- `-l`: output the leaves only;
- `--indel_size_zipf`: size of indel segment sampled from Zipf distribution.
3) Convert `unimog` file to `gen` files:
```bash
./unimog2gen.sh dummy_data.unimog
```
4) Run DCJ-indel:
```bash
ls *.gen | xargs ../60-matrix/gen_pairwise_comparisons.py | parallel --colsep '\t' ../60-matrix/dcj/dcjindel.sh {} | tr '\t' ',' | ../60-matrix/build_distance_matrix.py - > dcj_matrix.csv
```
5) Run Rank:
```bash
ls *.gen | xargs ../60-matrix/gen_pairwise_comparisons.py | parallel --colsep '\t' ../60-matrix/rank-joao/dist.py 0 0 {} | tr '\t' ',' | ../60-matrix/build_distance_matrix.py - > rank_matrix.csv
```
6) Run Rank-Indel:
```bash
ls *.gen | xargs ../60-matrix/gen_pairwise_comparisons.py | parallel --colsep '\t' ../60-matrix/rank-joao/dist.py 0 1 {} | tr '\t' ',' | ../60-matrix/build_distance_matrix.py - > rankindl_matrix.csv
```
7) Plot trees using distance matrices generated by (4), (5), and (6).
For the tree generated in (1) by the seed provided, the outgroup is L20.
```bash
../70-tree/rooted-nj-tree-with-outgroup.R rank_matrix.csv rank_tree L20
../70-tree/rooted-nj-tree-with-outgroup.R rankindl_matrix.csv rankindl_tree L20
../70-tree/rooted-nj-tree-with-outgroup.R dcj_matrix.csv dcj_tree L20
```
8) Finally, load the Newick files in `analysis.ipynb` and make comparisons and plots!

## Shorthands
The pipeline for the rank distance can be easily run as follows:
```bash
make rank_tree
make rankindl_tree
```
The DCJ pipeline, on the other hand, relies on Python 2 in an intermidiate step.
The steps must be the following:
```bash
make unimog2gen        # this will run up to the generation of the Gen files
conda activate dcj     # activate env with python 2
ls *.gen | xargs ../60-matrix/gen_pairwise_comparisons.py | parallel -j 7 --colsep '\t' ../60-matrix/dcj/dcjindel.sh {} | tr '\t' ',' | ../60-matrix/build_distance_matrix.py - > dcj_matrix.csv
conda deactivate
../70-tree/rooted-nj-tree-with-outgroup.R dcj_matrix.csv dcj_tree L20
```

## Measuring performance
The performance measure should be done when the distance is computed.
After having generated the Gen files, run the following:
```bash
ls *.gen | xargs ../60-matrix/gen_pairwise_comparisons.py > comparisons.txt
time cat comparisons.txt | parallel --colsep '\t' ${DIST} {}
```
where `DIST` is the script that computes a rearrangement distance.
